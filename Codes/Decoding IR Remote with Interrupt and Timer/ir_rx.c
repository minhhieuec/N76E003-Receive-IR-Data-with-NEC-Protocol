/*
 *	@author:	MinhHieuEC
 *	@date:		30/11/2019
 */
#include "ir_rx.h"

#define delay_ms(x) Timer2_Delay500us(x * 2)
#define debug printf

#define sync_high 17000 // 22000 Ã 0.75ms = 16.5ms
#define sync_low 12000  // 14000 Ã 0.75ms = 10.5ms
#define one_high 3600   // 3600 Ã 0.75ms = 2.7ms
#define one_low 2000    // 2400 Ã 0.75ms = 1.8ms
#define zero_high 1800  // 1800 Ã 0.75ms = 1.35ms
#define zero_low 800    // 1200 Ã 0.75ms = 0.9ms

//	1: start ir byte + IR_DATA_NUM_BYTES*8 bytes data
#define IR_RECEIVE_BYTE ((IR_DATA_LEN * 8) + 1)

bit is_ir_received = 0;
unsigned char bits = 0;
unsigned int frames[IR_RECEIVE_BYTE] = {0};

bit is_ir_start = 0;

uint8_t ir_receiver_type = IR_USE_EXT1_IT;

static void set_Timer_0(unsigned int value)
{
  TH0 = ((value && 0xFF00) >> 8);
  TL0 = (value & 0x00FF);
}

static unsigned int get_Timer_0(void)
{
  unsigned int value = 0x0000;

  value = TH0;
  value <<= 8;
  value |= TL0;

  return value;
}

static void erase_frames(void)
{
  for (bits = 0; bits < IR_RECEIVE_BYTE; bits++)
  {
    frames[bits] = 0;
  }

  set_Timer_0(0x0000);
  is_ir_received = 0;
  bits = 0;
  is_ir_start = 0;
}

void EXTI1_ISR(void) interrupt 2
{
  frames[bits] = get_Timer_0();

  // detect start
  if (frames[bits] > 17000 && frames[bits] < 20000)
    is_ir_start = 1;

  if (is_ir_start)
    bits++;

  set_Timer_0(0x0000);
  set_TR0;

  //  frame error detect
  if (frames[bits] < 0)
  {
    is_ir_start = 0;
    bits = 0;
  }

  if (bits >= IR_RECEIVE_BYTE)
  {
    is_ir_received = 1;
    clr_EA;
    clr_TR0;
  }
}

void PinInterrupt_ISR(void) interrupt 7
{
  if (PIF == 0x20)
  {
    frames[bits] = get_Timer_0();

    // detect start
    if (frames[bits] > 17000 && frames[bits] < 20000)
      is_ir_start = 1;

    if (is_ir_start)
      bits++;

    set_Timer_0(0x0000);
    set_TR0;

    //  frame error detect
    if (frames[bits] < 0)
    {
      is_ir_start = 0;
      bits = 0;
    }

    if (bits >= IR_RECEIVE_BYTE)
    {
      is_ir_received = 1;
      clr_EA;
      clr_TR0;
    }

    PIF = 0x00; //clear interrupt flag
  }
}

/*
*	@brief: setup necessary things for read IR data
* - setup timer0 mode 1
*   timer_tick = 12/16MHz = 0.75us
* - setup INT1 and enable all interrupt
* - if use IR_USE_PIN_IT, please set pin is input_mode,
*/
void ir_rx_setup(IR_Type_t ir_type)
{
  erase_frames();
  TIMER0_MODE1_ENABLE;
  set_Timer_0(0x0000);

  switch (ir_type)
  {
  case IR_USE_EXT1_IT:
    set_IT1; // falling edge triggered
    set_EX1; // Interrupt generated by pin (P1.7) Enabled.
    break;

  case IR_USE_PIN_IT:
    set_EPI; // Enable pin interrupt
    break;

  default:
    break;
  }

  set_EA; // global enable bit
}

static unsigned char decode(unsigned char start_pos, unsigned char end_pos)
{
  unsigned char value = 0;

  for (bits = start_pos; bits <= end_pos; bits++)
  {
    value <<= 1;

    if ((frames[bits] >= one_low) && (frames[bits] <= one_high))
    {
      value |= 1;
    }

    else if ((frames[bits] >= zero_low) && (frames[bits] <= zero_high))
    {
      value |= 0;
    }

    else if ((frames[bits] >= sync_low) && (frames[bits] <= sync_high))
    {
      return 0xFF;
    }
  }

  return value;
}

uint8_t is_ir_data_received(void) { return is_ir_received; }

void get_ir_data(uint8_t *buf, uint8_t len)
{
  uint8_t cnt;
  uint8_t idx = 0;

  for (cnt = 0; cnt < len * 8; cnt += 8)
  {
    buf[idx] = decode(cnt + 1, cnt + 8);
    idx++;
  }

  delay_ms(1);

  erase_frames();
  set_EA; //	enable all interrupt
}
