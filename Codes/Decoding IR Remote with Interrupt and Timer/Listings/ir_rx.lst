C51 COMPILER V9.60.0.0   IR_RX                                                             12/03/2019 11:54:43 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE IR_RX
OBJECT MODULE PLACED IN .\Objects\ir_rx.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ir_rx.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\..\Include;..\..\My_Lib
                    -raries\2 Wire LCD  (Software Delay);..\..\My_Libraries\Software Delay) DEFINE(FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\Li
                    -stings\ir_rx.lst) TABS(2) OBJECT(.\Objects\ir_rx.obj)

line level    source

   1          /*
   2           *  @author:  MinhHieuEC
   3           *  @date:    30/11/2019
   4           */
   5          #include "ir_rx.h"
   6          
   7          #define delay_ms(x) Timer2_Delay500us(x * 2)
   8          #define debug printf
   9          
  10          #define sync_high          17000 // 22000 Ã 0.75ms = 16.5ms
  11          #define sync_low           12000 // 14000 Ã 0.75ms = 10.5ms
  12          #define one_high            3600 // 3600 Ã 0.75ms = 2.7ms
  13          #define one_low             2000 // 2400 Ã 0.75ms = 1.8ms
  14          #define zero_high           1800 // 1800 Ã 0.75ms = 1.35ms
  15          #define zero_low            800 // 1200 Ã 0.75ms = 0.9ms
  16          
  17          //  1: start ir byte + IR_DATA_NUM_BYTES*8 bytes data
  18          #define IR_DATA_NUM_BYTES 8
  19          #define IR_RECEIVE_BYTE ((IR_DATA_NUM_BYTES * 8) + 1)
  20          
  21          bit received = 0;
  22          unsigned char bits = 0;
  23          unsigned int frames[IR_RECEIVE_BYTE] = {0};
  24          
  25          bit is_ir_start = 0;
  26          bit is_first_ir_time = 0;
  27          
  28          void set_Timer_0(unsigned int value);
  29          unsigned int get_Timer_0(void);
  30          unsigned char decode(unsigned char start_pos, unsigned char end_pos);
  31          
  32          void EXTI1_ISR(void) interrupt 2 {
  33   1        frames[bits] = get_Timer_0();
  34   1      
  35   1        // detect start
  36   1        if (frames[bits] > 17000 && frames[bits] < 20000) is_ir_start = 1;
  37   1      
  38   1        if (is_ir_start) bits++;
  39   1      
  40   1        set_Timer_0(0x0000);
  41   1        set_TR0;
  42   1      
  43   1        //  frame error detect
  44   1        if (frames[bits] < 0) {
  45   2          is_ir_start = 0;
  46   2          bits = 0;
  47   2        }
  48   1      
  49   1        if (bits >= IR_RECEIVE_BYTE) {
  50   2          received = 1;
  51   2          clr_EA;
  52   2          clr_TR0;
  53   2        }
C51 COMPILER V9.60.0.0   IR_RX                                                             12/03/2019 11:54:43 PAGE 2   

  54   1      }
  55          
  56          /*
  57          * @brief: setup neccessary things for read IR data
  58          * - setup timer0 mode 1
  59          *   timer_tick = 12/16MHz = 0.75us
  60          * - setup INT1 and enable all interrupt
  61          */
  62          void ir_rx_setup(void) {
  63   1        erase_frames();
  64   1        TIMER0_MODE1_ENABLE;
  65   1        set_Timer_0(0x0000);
  66   1        set_IT1;
  67   1        set_EX1;
  68   1        set_EA;
  69   1      }
  70          
  71          void set_Timer_0(unsigned int value) {
  72   1        TH0 = ((value && 0xFF00) >> 8);
  73   1        TL0 = (value & 0x00FF);
  74   1      }
  75          
  76          unsigned int get_Timer_0(void) {
  77   1        unsigned int value = 0x0000;
  78   1      
  79   1        value = TH0;
  80   1        value <<= 8;
  81   1        value |= TL0;
  82   1      
  83   1        return value;
  84   1      }
  85          
  86          void erase_frames(void) {
  87   1        for (bits = 0; bits < IR_RECEIVE_BYTE; bits++) {
  88   2          frames[bits] = 0;
  89   2        }
  90   1      
  91   1        set_Timer_0(0x0000);
  92   1        received = 0;
  93   1        bits = 0;
  94   1        is_ir_start = 0;
  95   1      }
  96          
  97          unsigned char decode(unsigned char start_pos, unsigned char end_pos) {
  98   1        unsigned char value = 0;
  99   1      
 100   1        for (bits = start_pos; bits <= end_pos; bits++) {
 101   2          value <<= 1;
 102   2      
 103   2          if ((frames[bits] >= one_low) && (frames[bits] <= one_high)) {
 104   3            value |= 1;
 105   3          }
 106   2      
 107   2          else if ((frames[bits] >= zero_low) && (frames[bits] <= zero_high)) {
 108   3            value |= 0;
 109   3          }
 110   2      
 111   2          else if ((frames[bits] >= sync_low) && (frames[bits] <= sync_high)) {
 112   3            return 0xFF;
 113   3          }
 114   2        }
 115   1      
C51 COMPILER V9.60.0.0   IR_RX                                                             12/03/2019 11:54:43 PAGE 3   

 116   1        return value;
 117   1      }
 118          
 119          void decode_NEC_IR(void) {
 120   1        uint8_t ir_data[8];
 121   1      
 122   1        ir_data[0] = decode(1, 8);
 123   1        ir_data[1] = decode(9, 16);
 124   1        ir_data[2] = decode(17, 24);
 125   1        ir_data[3] = decode(15, 32);
 126   1      
 127   1        ir_data[4] = decode(33, 40);
 128   1        ir_data[5] = decode(41, 48);
 129   1        ir_data[6] = decode(49, 56);
 130   1        ir_data[7] = decode(57, 64);
 131   1      
 132   1        debug("%x %x %x %x | %x %x %x %x\r\n", (uint16_t)ir_data[0],
 133   1              (uint16_t)ir_data[1], (uint16_t)ir_data[2], (uint16_t)ir_data[3],
 134   1              (uint16_t)ir_data[4], (uint16_t)ir_data[5], (uint16_t)ir_data[6],
 135   1              (uint16_t)ir_data[7]);
 136   1        
 137   1        delay_ms(200);
 138   1        
 139   1        erase_frames();
 140   1        set_EA; //  enable all interrupt
 141   1      }
 142          
 143          uint8_t is_ir_data_received(void) { return received; }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    663    ----
   CONSTANT SIZE    =     28    ----
   XDATA SIZE       =    131       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
