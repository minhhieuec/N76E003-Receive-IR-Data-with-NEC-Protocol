C51 COMPILER V9.60.0.0   IR_RX                                                             11/30/2019 15:48:16 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE IR_RX
OBJECT MODULE PLACED IN .\Objects\ir_rx.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ir_rx.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\..\Include;..\..\My_Lib
                    -raries\2 Wire LCD  (Software Delay);..\..\My_Libraries\Software Delay) DEFINE(FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\Li
                    -stings\ir_rx.lst) TABS(2) OBJECT(.\Objects\ir_rx.obj)

line level    source

   1          /*
   2           *  @author:  MinhHieuEC
   3           *  @date:    30/11/2019
   4           */
   5          #include "ir_rx.h"
   6          
   7          #define delay_ms(x) Timer2_Delay500us(x * 2)
   8          #define debug printf
   9          
  10          #define sync_high 12000  // 12000 × 0.75ms = 9ms
  11          #define sync_low 6000    // 6000 × 0.75ms = 4.5ms
  12          #define one_high 3600    // 3600 × 0.75ms = 2.7ms
  13          #define one_low 2400     // 2400 × 0.75ms = 1.8ms
  14          #define zero_high 1800   // 1800 × 0.75ms = 1.35ms
  15          #define zero_low 1200    // 1200 × 0.75ms = 0.9ms
  16          
  17          //  1: start ir byte + IR_DATA_NUM_BYTES*8 bytes data
  18          #define IR_DATA_NUM_BYTES 8
  19          #define IR_RECEIVE_BYTE ((IR_DATA_NUM_BYTES * 8) + 1)
  20          
  21          bit received = 0;
  22          unsigned char bits = 0;
  23          unsigned int frames[IR_RECEIVE_BYTE] = {0};
  24          
  25          bit is_ir_start = 0;
  26          bit is_first_ir_time = 0;
  27          
  28          void set_Timer_0(unsigned int value);
  29          unsigned int get_Timer_0(void);
  30          unsigned char decode(unsigned char start_pos, unsigned char end_pos);
  31          
  32          void EXTI1_ISR(void) interrupt 2 {
  33   1        if (is_ir_start) {
  34   2          frames[bits] = get_Timer_0();
  35   2          bits++;
  36   2      
  37   2          set_Timer_0(0x0000);
  38   2          set_TR0;
  39   2      
  40   2          if (bits >= IR_RECEIVE_BYTE) {
  41   3            received = 1;
  42   3            clr_EA;
  43   3            clr_TR0;
  44   3          }
  45   2        } else {
  46   2          //  detect first start sync
  47   2          if (is_first_ir_time == 0) {
  48   3            is_ir_start = 1;
  49   3            set_TR0;
  50   3            is_first_ir_time = 1;
  51   3          } else {
  52   3            //  remove end ir before get new start sync
  53   3            is_first_ir_time = 0;
C51 COMPILER V9.60.0.0   IR_RX                                                             11/30/2019 15:48:16 PAGE 2   

  54   3          }
  55   2        }
  56   1      }
  57          
  58          /*
  59          * @brief: setup neccessary things for read IR data
  60          * - setup timer0 mode 1
  61          *   timer_tick = 12/16MHz = 0.75us
  62          * - setup INT1 and enable all interrupt
  63          */
  64          void ir_rx_setup(void) {
  65   1        erase_frames();
  66   1        TIMER0_MODE1_ENABLE;
  67   1        set_Timer_0(0x0000);
  68   1        set_IT1;
  69   1        set_EX1;
  70   1        set_EA;
  71   1      }
  72          
  73          void set_Timer_0(unsigned int value) {
  74   1        TH0 = ((value && 0xFF00) >> 8);
  75   1        TL0 = (value & 0x00FF);
  76   1      }
  77          
  78          unsigned int get_Timer_0(void) {
  79   1        unsigned int value = 0x0000;
  80   1      
  81   1        value = TH0;
  82   1        value <<= 8;
  83   1        value |= TL0;
  84   1      
  85   1        return value;
  86   1      }
  87          
  88          void erase_frames(void) {
  89   1        for (bits = 0; bits < IR_RECEIVE_BYTE; bits++) {
  90   2          frames[bits] = 0;
  91   2        }
  92   1      
  93   1        set_Timer_0(0x0000);
  94   1        received = 0;
  95   1        bits = 0;
  96   1        is_ir_start = 0;
  97   1      }
  98          
  99          unsigned char decode(unsigned char start_pos, unsigned char end_pos) {
 100   1        unsigned char value = 0;
 101   1      
 102   1        for (bits = start_pos; bits <= end_pos; bits++) {
 103   2          value <<= 1;
 104   2      
 105   2          if ((frames[bits] >= one_low) && (frames[bits] <= one_high)) {
 106   3            value |= 1;
 107   3          }
 108   2      
 109   2          else if ((frames[bits] >= zero_low) && (frames[bits] <= zero_high)) {
 110   3            value |= 0;
 111   3          }
 112   2      
 113   2          else if ((frames[bits] >= sync_low) && (frames[bits] <= sync_high)) {
 114   3            return 0xFF;
 115   3          }
C51 COMPILER V9.60.0.0   IR_RX                                                             11/30/2019 15:48:16 PAGE 3   

 116   2        }
 117   1      
 118   1        return value;
 119   1      }
 120          
 121          void decode_NEC_IR(void) {
 122   1        uint8_t ir_data[8];
 123   1      
 124   1        ir_data[0] = decode(1, 8);
 125   1        ir_data[1] = decode(9, 16);
 126   1        ir_data[2] = decode(17, 24);
 127   1        ir_data[3] = decode(15, 32);
 128   1      
 129   1        ir_data[4] = decode(33, 40);
 130   1        ir_data[5] = decode(41, 48);
 131   1        ir_data[6] = decode(49, 56);
 132   1        ir_data[7] = decode(57, 64);
 133   1      
 134   1        debug("%x %x %x %x | %x %x %x %x\r\n", (uint16_t)ir_data[0],
 135   1              (uint16_t)ir_data[1], (uint16_t)ir_data[2], (uint16_t)ir_data[3],
 136   1              (uint16_t)ir_data[4], (uint16_t)ir_data[5], (uint16_t)ir_data[6],
 137   1              (uint16_t)ir_data[7]);
 138   1        
 139   1        delay_ms(200);
 140   1        
 141   1        erase_frames();
 142   1        set_EA; //  enable all interrupt
 143   1      }
 144          
 145          uint8_t is_ir_data_received(void) { return received; }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    612    ----
   CONSTANT SIZE    =     28    ----
   XDATA SIZE       =    131       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
